From cdae9c26ad45e5ffe3b414f3f9936eb99fbd4a06 Mon Sep 17 00:00:00 2001
From: Thomas Woertman <twoertman@gmail.com>
Date: Fri, 16 Aug 2019 14:39:38 +0200
Subject: [PATCH] Create Sigma sysdeps

---
 abis/sigma/abi.h                             |  23 +++++
 abis/sigma/auxv.h                            |   9 ++
 meson.build                                  |  20 +++-
 sysdeps/sigma/crt-src/crt0.S                 |   5 +
 sysdeps/sigma/generic/entry.cpp              |  28 +++++
 sysdeps/sigma/generic/generic.cpp            | 102 +++++++++++++++++++
 sysdeps/sigma/generic/log.cpp                |  22 ++++
 sysdeps/sigma/generic/memory.cpp             |  24 +++++
 sysdeps/sigma/include/abi-bits/abi.h         |   1 +
 sysdeps/sigma/include/abi-bits/auxv.h        |   1 +
 sysdeps/sigma/include/abi-bits/seek-whence.h |   1 +
 sysdeps/sigma/include/abi-bits/vm-flags.h    |   1 +
 sysdeps/sigma/meson.build                    |  40 ++++++++
 sysdeps/sigma/rtdl-generic/support.cpp       | 100 ++++++++++++++++++
 14 files changed, 375 insertions(+), 2 deletions(-)
 create mode 100644 abis/sigma/abi.h
 create mode 100644 abis/sigma/auxv.h
 create mode 100644 sysdeps/sigma/crt-src/crt0.S
 create mode 100644 sysdeps/sigma/generic/entry.cpp
 create mode 100644 sysdeps/sigma/generic/generic.cpp
 create mode 100644 sysdeps/sigma/generic/log.cpp
 create mode 100644 sysdeps/sigma/generic/memory.cpp
 create mode 120000 sysdeps/sigma/include/abi-bits/abi.h
 create mode 120000 sysdeps/sigma/include/abi-bits/auxv.h
 create mode 120000 sysdeps/sigma/include/abi-bits/seek-whence.h
 create mode 120000 sysdeps/sigma/include/abi-bits/vm-flags.h
 create mode 100644 sysdeps/sigma/meson.build
 create mode 100644 sysdeps/sigma/rtdl-generic/support.cpp

diff --git a/abis/sigma/abi.h b/abis/sigma/abi.h
new file mode 100644
index 0000000..55fbd68
--- /dev/null
+++ b/abis/sigma/abi.h
@@ -0,0 +1,23 @@
+
+// reserve 3 bits for the access mode
+#define __MLIBC_O_ACCMODE 0x0007
+#define __MLIBC_O_EXEC 1
+#define __MLIBC_O_RDONLY 2
+#define __MLIBC_O_RDWR 3
+#define __MLIBC_O_SEARCH 4
+#define __MLIBC_O_WRONLY 5
+// all remaining flags get their own bit
+#define __MLIBC_O_APPEND 0x0008
+#define __MLIBC_O_CREAT 0x0010
+#define __MLIBC_O_DIRECTORY 0x0020
+#define __MLIBC_O_EXCL 0x0040
+#define __MLIBC_O_NOCTTY 0x0080
+#define __MLIBC_O_NOFOLLOW 0x0100
+#define __MLIBC_O_TRUNC 0x0200
+#define __MLIBC_O_NONBLOCK 0x0400
+#define __MLIBC_O_DSYNC 0x0800
+#define __MLIBC_O_RSYNC 0x1000
+#define __MLIBC_O_SYNC 0x2000
+#define __MLIBC_O_CLOEXEC 0x4000
+
+
diff --git a/abis/sigma/auxv.h b/abis/sigma/auxv.h
new file mode 100644
index 0000000..0785c53
--- /dev/null
+++ b/abis/sigma/auxv.h
@@ -0,0 +1,9 @@
+#ifndef _ABIBITS_AUXV_H
+#define _ABIBITS_AUXV_H
+
+#define AT_PHDR 3
+#define AT_PHENT 4
+#define AT_PHNUM 5
+#define AT_ENTRY 9
+
+#endif
\ No newline at end of file
diff --git a/meson.build b/meson.build
index af40915..ba654e7 100644
--- a/meson.build
+++ b/meson.build
@@ -15,6 +15,9 @@ rtdl_sources = [ ]
 libc_sources = [ ]
 libc_sublibs = [ ]
 
+libc_deps = [ ]
+rtdl_deps = [ ]
+
 headers_only = get_option('headers_only')
 no_headers = get_option('mlibc_no_headers')
 disable_ansi_option = false
@@ -24,8 +27,13 @@ internal_conf = configuration_data()
 
 if not headers_only
 	cxxshim_dep = subproject('cxxshim').get_variable('cxxshim_dep')
+	libc_deps += cxxshim_dep
+	rtdl_deps += cxxshim_dep
 	frigg_dep = subproject('frigg',
 		default_options: ['frigg_no_install=true']).get_variable('frigg_dep')
+	libc_deps += frigg_dep
+	rtdl_deps += frigg_dep
+
 
 	add_languages('c', 'cpp')
 	c_compiler = meson.get_compiler('c')
@@ -74,6 +82,14 @@ elif host_machine.system() == 'qword'
 	rtdl_include_dirs += include_directories('sysdeps/qword/include')
 	libc_include_dirs += include_directories('sysdeps/qword/include')
 	subdir('sysdeps/qword')
+elif host_machine.system() == 'sigma'
+	disable_linux_option = true
+	rtdl_include_dirs += include_directories('sysdeps/sigma/include')
+	libc_include_dirs += include_directories('sysdeps/sigma/include')
+	libsigma = dependency('sigma')
+	libc_deps += libsigma
+	rtdl_deps += libsigma
+	subdir('sysdeps/sigma')
 else
 	error('No sysdeps defined for OS: ' + host_machine.system())
 endif
@@ -159,7 +175,7 @@ if not headers_only
 			name_prefix: '',
 			cpp_args: ['-fvisibility=hidden', '-DMLIBC_BUILDING_RTDL', '-DFRIGG_HAVE_LIBC'],
 			include_directories: rtdl_include_dirs,
-			dependencies: [cxxshim_dep, frigg_dep],
+			dependencies: rtdl_deps,
 			install: true)
 
 	shared_library('c',
@@ -171,7 +187,7 @@ if not headers_only
 			],
 			cpp_args: ['-DFRIGG_HAVE_LIBC'],
 			include_directories: libc_include_dirs,
-			dependencies: [cxxshim_dep, frigg_dep],
+			dependencies: libc_deps,
 			link_with: [ldso_lib],
 			link_whole: libc_sublibs,
 			install: true)
diff --git a/sysdeps/sigma/crt-src/crt0.S b/sysdeps/sigma/crt-src/crt0.S
new file mode 100644
index 0000000..e331397
--- /dev/null
+++ b/sysdeps/sigma/crt-src/crt0.S
@@ -0,0 +1,5 @@
+.section .text
+.global _start
+_start:
+    mov $main, %rdi
+    call __mlibc_entry
\ No newline at end of file
diff --git a/sysdeps/sigma/generic/entry.cpp b/sysdeps/sigma/generic/entry.cpp
new file mode 100644
index 0000000..917335c
--- /dev/null
+++ b/sysdeps/sigma/generic/entry.cpp
@@ -0,0 +1,28 @@
+#include <stdint.h>
+#include <stdlib.h>
+#include <bits/ensure.h>
+#include <mlibc/elf/startup.h>
+
+void __mlibc_initLocale();
+
+extern "C" uintptr_t* __dlapi_entrystack();
+
+extern char** environ;
+static mlibc::exec_stack_data __mlibc_stack_data;
+
+struct LibraryGuard {
+    LibraryGuard();
+};
+
+static LibraryGuard guard;
+
+LibraryGuard::LibraryGuard(){
+    __mlibc_initLocale();
+
+    mlibc::parse_exec_stack(__dlapi_entrystack(), &__mlibc_stack_data);
+    mlibc::set_startup_data(__mlibc_stack_data.argc, __mlibc_stack_data.argv, __mlibc_stack_data.envp);
+}
+
+extern "C" void __mlibc_entry(int (*main_fn)(int argc, char *argv[], char *env[])){
+    exit(main_fn(__mlibc_stack_data.argc, __mlibc_stack_data.argv, environ));
+}
\ No newline at end of file
diff --git a/sysdeps/sigma/generic/generic.cpp b/sysdeps/sigma/generic/generic.cpp
new file mode 100644
index 0000000..0640fae
--- /dev/null
+++ b/sysdeps/sigma/generic/generic.cpp
@@ -0,0 +1,102 @@
+#include <mlibc/sysdeps.hpp>
+#include <bits/ensure.h>
+#include <mlibc/debug.hpp>
+#include <errno.h>
+#include <dirent.h>
+#include <fcntl.h>
+
+#include <libsigma/thread.h>
+
+
+#define STUB_ONLY { __ensure(!"STUB_ONLY function was called"); __builtin_unreachable(); }
+
+namespace mlibc {
+    // Unknown Functions
+    int sys_tcb_set(void *pointer){
+	    libsigma_set_fsbase(reinterpret_cast<uint64_t>(pointer));
+        return 0;
+    }
+    
+    int sys_sigaction(int signum, const struct sigaction *act, struct sigaction *oldact) STUB_ONLY
+    
+    // Memory Related Functions
+    int sys_vm_map(void *hint, size_t size, int prot, int flags, int fd, off_t offset, void **window) STUB_ONLY
+    #ifndef MLIBC_BUILDING_RTDL
+    int sys_vm_remap(void *pointer, size_t size, size_t new_size, void **window) STUB_ONLY
+    #endif
+    int sys_vm_unmap(void *pointer, size_t size) STUB_ONLY
+
+    // Misc functions
+    #ifndef MLIBC_BUILDING_RTDL
+    int sys_clock_get(int clock, time_t *secs, long *nanos) STUB_ONLY
+    int sys_futex_wait(int *pointer, int expected) STUB_ONLY
+    int sys_futex_wake(int *pointer) STUB_ONLY
+    #endif
+
+    // Task functions
+    #ifndef MLIBC_BUILDING_RTDL
+    void sys_exit(int status) STUB_ONLY
+    int sys_sleep(time_t *secs, long *nanos) STUB_ONLY
+    int sys_fork(pid_t *child) STUB_ONLY
+    int sys_execve(const char *path, char *const argv[], char *const envp[]) STUB_ONLY
+    int sys_kill(pid_t pid, int signal) STUB_ONLY
+    int sys_waitpid(pid_t pid, int *status, int flags, pid_t *ret_pid) STUB_ONLY
+    int sys_getrusage(int who, struct rusage *usage) STUB_ONLY
+    int sys_sigprocmask(int how, const sigset_t *__restrict set, sigset_t *__restrict retrieve) STUB_ONLY
+    void sys_yield() STUB_ONLY
+    gid_t sys_getgid() STUB_ONLY
+    gid_t sys_getegid() STUB_ONLY
+    uid_t sys_getuid() STUB_ONLY
+    uid_t sys_geteuid() STUB_ONLY
+    pid_t sys_getpid() STUB_ONLY
+    pid_t sys_getppid() STUB_ONLY
+    #endif
+
+    // File functions
+    int sys_open(const char *path, int flags, int *fd) STUB_ONLY
+    int sys_close(int fd) STUB_ONLY
+    int sys_seek(int fd, off_t offset, int whence, off_t *new_offset) STUB_ONLY
+    int sys_read(int fd, void *buf, size_t count, ssize_t *bytes_read) STUB_ONLY
+
+    #ifndef MLIBC_BUILDING_RTDL
+    int sys_write(int fd, const void *buf, size_t count, ssize_t *bytes_written) STUB_ONLY
+    int sys_ioctl(int fd, unsigned long request, void *arg, int *result) STUB_ONLY
+    int sys_stat(fsfd_target fsfdt, int fd, const char *path, int flags, struct stat *statbuf) STUB_ONLY
+    int sys_rename(const char *path, const char *new_path) STUB_ONLY
+    int sys_open_dir(const char *path, int *handle) STUB_ONLY
+    int sys_read_entries(int handle, void *buffer, size_t max_size, size_t *bytes_read) STUB_ONLY
+    int sys_access(const char *path, int mode) STUB_ONLY
+    int sys_dup(int fd, int flags, int *newfd) STUB_ONLY
+    int sys_dup2(int fd, int flags, int newfd) STUB_ONLY
+    int sys_isatty(int fd) STUB_ONLY
+    int sys_ttyname(int fd, char *buf, size_t size) STUB_ONLY
+    int sys_chroot(const char *path) STUB_ONLY
+    int sys_mkdir(const char *path) STUB_ONLY
+    int sys_tcgetattr(int fd, struct termios *attr) STUB_ONLY
+    int sys_tcsetattr(int fd, int optional_action, const struct termios *attr) STUB_ONLY
+    int sys_tcflow(int fd, int action) STUB_ONLY
+    int sys_pipe(int *fds, int flags) STUB_ONLY
+    int sys_readlink(const char *path, void *buffer, size_t max_size, ssize_t *length) STUB_ONLY
+    int sys_ftruncate(int fd, size_t size) STUB_ONLY
+    int sys_fallocate(int fd, off_t offset, size_t size) STUB_ONLY
+    int sys_unlink(const char *path) STUB_ONLY
+    int sys_symlink(const char *target_path, const char *link_path) STUB_ONLY
+    int sys_fcntl(int fd, int request, va_list args, int *result) STUB_ONLY
+    #endif
+
+    // Network related functions
+    #ifndef MLIBC_BUILDING_RTDL
+    int sys_socket(int family, int type, int protocol, int *fd) STUB_ONLY
+    int sys_socketpair(int domain, int type_and_flags, int proto, int *fds) STUB_ONLY
+    int sys_accept(int fd, int *newfd) STUB_ONLY
+    int sys_bind(int fd, const struct sockaddr *addr_ptr, socklen_t addr_length) STUB_ONLY
+    int sys_connect(int fd, const struct sockaddr *addr_ptr, socklen_t addr_length) STUB_ONLY
+    int sys_msg_send(int fd, const struct msghdr *hdr, int flags, ssize_t *length) STUB_ONLY
+    int sys_msg_recv(int fd, struct msghdr *hdr, int flags, ssize_t *length) STUB_ONLY
+    int sys_sockname(int fd, struct sockaddr *addr_ptr, socklen_t max_addr_length, socklen_t *actual_length) STUB_ONLY
+    int sys_getsockopt(int fd, int layer, int number, void *__restrict buffer, socklen_t *__restrict size) STUB_ONLY
+    int sys_setsockopt(int fd, int layer, int number, const void *buffer, socklen_t size) STUB_ONLY
+    #endif
+
+
+}
\ No newline at end of file
diff --git a/sysdeps/sigma/generic/log.cpp b/sysdeps/sigma/generic/log.cpp
new file mode 100644
index 0000000..83ad85c
--- /dev/null
+++ b/sysdeps/sigma/generic/log.cpp
@@ -0,0 +1,22 @@
+#include <string.h>
+#include <assert.h>
+
+#include <bits/ensure.h>
+#include <mlibc/debug.hpp>
+#include <mlibc/sysdeps.hpp>
+
+#include <libsigma/klog.h>
+
+#define UNIMPLEMENTED() { __ensure(!"Unimplemented function was called"); __builtin_unreachable(); }
+
+namespace mlibc
+{
+    void sys_libc_log(const char *message) {
+        libsigma_klog(message);
+    }
+
+    void sys_libc_panic(){
+        mlibc::infoLogger() << "\e[31mmlibc: panic!" << frg::endlog;
+        UNIMPLEMENTED();
+    }
+} // namespace mlibc
diff --git a/sysdeps/sigma/generic/memory.cpp b/sysdeps/sigma/generic/memory.cpp
new file mode 100644
index 0000000..7d5ebdc
--- /dev/null
+++ b/sysdeps/sigma/generic/memory.cpp
@@ -0,0 +1,24 @@
+#include <string.h>
+
+#include <bits/ensure.h>
+#include <mlibc/sysdeps.hpp>
+#include <mlibc/debug.hpp>
+#include <libsigma/memory.h>
+
+#define STUB_ONLY { __ensure(!"STUB_ONLY function was called"); __builtin_unreachable(); }
+
+namespace mlibc
+{
+    int sys_anon_allocate(size_t size, void **pointer){
+        __ensure((size & 0xFFF) == 0);
+        uint64_t ret = libsigma_valloc(LIBSIGMA_VALLOC_TYPE_SBRK_LIKE, 0, size / 0x1000);
+        if(ret == 1) return 1;
+        *pointer = (void*)ret;
+
+        return 0;
+    }
+    int sys_anon_free(void *pointer, size_t size){
+        mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!" << frg::endlog;
+        return 0;
+    }
+} // namespace mlibc
diff --git a/sysdeps/sigma/include/abi-bits/abi.h b/sysdeps/sigma/include/abi-bits/abi.h
new file mode 120000
index 0000000..5cbf52e
--- /dev/null
+++ b/sysdeps/sigma/include/abi-bits/abi.h
@@ -0,0 +1 @@
+../../../../abis/sigma/abi.h
\ No newline at end of file
diff --git a/sysdeps/sigma/include/abi-bits/auxv.h b/sysdeps/sigma/include/abi-bits/auxv.h
new file mode 120000
index 0000000..9eae830
--- /dev/null
+++ b/sysdeps/sigma/include/abi-bits/auxv.h
@@ -0,0 +1 @@
+../../../../abis/sigma/auxv.h
\ No newline at end of file
diff --git a/sysdeps/sigma/include/abi-bits/seek-whence.h b/sysdeps/sigma/include/abi-bits/seek-whence.h
new file mode 120000
index 0000000..3bd41ef
--- /dev/null
+++ b/sysdeps/sigma/include/abi-bits/seek-whence.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/seek-whence.h
\ No newline at end of file
diff --git a/sysdeps/sigma/include/abi-bits/vm-flags.h b/sysdeps/sigma/include/abi-bits/vm-flags.h
new file mode 120000
index 0000000..f1a985e
--- /dev/null
+++ b/sysdeps/sigma/include/abi-bits/vm-flags.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/vm-flags.h
\ No newline at end of file
diff --git a/sysdeps/sigma/meson.build b/sysdeps/sigma/meson.build
new file mode 100644
index 0000000..d5adc12
--- /dev/null
+++ b/sysdeps/sigma/meson.build
@@ -0,0 +1,40 @@
+sigma_incl = include_directories('../../subprojects/libsigma/include')
+#		'../../subprojects/managarm/hel/include')
+
+rtdl_include_dirs += sigma_incl
+rtdl_sources += files(
+	'generic/log.cpp',
+	'generic/memory.cpp',
+	'rtdl-generic/support.cpp',
+)
+
+#libc_include_dirs += include_directories('../../../ports/libdrm/include')
+libc_include_dirs += sigma_incl
+
+libc_sources += files(
+	'generic/log.cpp',
+	'generic/entry.cpp',
+	'generic/memory.cpp',
+	'generic/generic.cpp',
+)
+
+if not no_headers
+	install_headers(
+		'include/abi-bits/abi.h',
+		'include/abi-bits/auxv.h',
+		'include/abi-bits/vm-flags.h',
+		subdir: 'abi-bits'
+	)
+endif
+
+if not headers_only
+	custom_target('crt0',
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: 'crt-src/crt0.S',
+		output: 'crt0.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+endif
+
diff --git a/sysdeps/sigma/rtdl-generic/support.cpp b/sysdeps/sigma/rtdl-generic/support.cpp
new file mode 100644
index 0000000..dc94f83
--- /dev/null
+++ b/sysdeps/sigma/rtdl-generic/support.cpp
@@ -0,0 +1,100 @@
+#include <stddef.h>
+#include <stdint.h>
+#include <string.h>
+
+#include <frg/vector.hpp>
+#include <frg/string.hpp>
+#include <frg/eternal.hpp>
+
+#include <mlibc/allocator.hpp>
+#include <mlibc/sysdeps.hpp>
+
+#include <libsigma/thread.h>
+#include <libsigma/file.h>
+#include <libsigma/memory.h>
+
+namespace {
+    class id_allocator{
+        public:
+        id_allocator(): id(0) {}
+
+        uint64_t get_id(){
+            return id++;
+        } 
+
+        private:
+        uint64_t id;
+    };
+
+    auto file_descriptor_allocator = id_allocator();
+
+    struct file_descriptor {
+        file_descriptor(): fd(0), offset(0), name(frg::string<MemoryAllocator>(getAllocator())) {}
+        file_descriptor(const char* name): fd(file_descriptor_allocator.get_id()), offset(0), name(frg::string<MemoryAllocator>(getAllocator(), name)) {}
+        uint64_t fd, offset;
+        frg::string<MemoryAllocator> name;
+    };
+
+    static frg::vector<file_descriptor, MemoryAllocator>& get_file_descriptor_list(){
+        static frg::eternal<frg::vector<file_descriptor, MemoryAllocator>> file_descriptor_list(getAllocator());
+        return file_descriptor_list.get();
+    }
+    
+}
+
+
+namespace mlibc {
+
+int sys_tcb_set(void *pointer) {
+	libsigma_set_fsbase(reinterpret_cast<uint64_t>(pointer));
+	return 0;
+}
+
+int sys_open(const char *path, int flags, int *fd){
+    auto& file = get_file_descriptor_list().push_back(file_descriptor(path));
+    (void)(flags);
+    *fd = file.fd;
+    return 0;
+}
+
+int sys_seek(int fd, off_t offset, int whence, off_t *new_offset){
+    __ensure(whence == SEEK_SET);
+
+    for(auto& file : get_file_descriptor_list()){
+        if(file.fd == fd){
+            file.offset = offset;
+            *new_offset = offset;
+            return 0;
+        }
+    }
+
+    return 1;
+}
+int sys_read(int fd, void *data, size_t length, ssize_t *bytes_read){
+    for(auto& file : get_file_descriptor_list()){
+        if(file.fd == fd){
+            if(libsigma_read_initrd_file(file.name.data(), (uint8_t*)data, file.offset, length)){
+                *bytes_read = 0;
+                return 1;
+            } else {
+                *bytes_read = length;
+                return 0;
+            }
+        }
+    }
+
+    return 1;
+}
+int sys_close(int fd){
+    return 0;
+}
+
+int sys_vm_map(void *hint, size_t size, int prot, int flags, int fd, off_t offset, void **window){
+    if(!(flags & MAP_ANONYMOUS)) __ensure(!"Anything else than MAP_ANONYMOUS is unimplemented");
+
+    int ret = libsigma_vm_map(size, hint, prot, flags);
+    *window = hint;
+    return ret;
+} // namespace mlibc
+
+}
-- 
2.20.1

