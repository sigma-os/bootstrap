From 1919aff64bdb0ce09071b456a143975fb7f5b844 Mon Sep 17 00:00:00 2001
From: Thomas Woertman <twoertman@gmail.com>
Date: Fri, 16 Aug 2019 14:39:38 +0200
Subject: [PATCH] Create Sigma sysdeps

---
 abis/sigma/abi.h                          | 23 ++++++
 abis/sigma/auxv.h                         |  9 +++
 meson.build                               |  5 ++
 sysdeps/sigma/crt-src/crt0.S              |  5 ++
 sysdeps/sigma/generic/entry.cpp           | 28 +++++++
 sysdeps/sigma/generic/generic.cpp         | 97 +++++++++++++++++++++++
 sysdeps/sigma/generic/log.cpp             | 21 +++++
 sysdeps/sigma/generic/memory.cpp          | 24 ++++++
 sysdeps/sigma/include/abi-bits/abi.h      |  1 +
 sysdeps/sigma/include/abi-bits/auxv.h     |  1 +
 sysdeps/sigma/include/abi-bits/vm-flags.h |  1 +
 sysdeps/sigma/meson.build                 | 40 ++++++++++
 sysdeps/sigma/rtld-generic/support.cpp    | 94 ++++++++++++++++++++++
 13 files changed, 349 insertions(+)
 create mode 100644 abis/sigma/abi.h
 create mode 100644 abis/sigma/auxv.h
 create mode 100644 sysdeps/sigma/crt-src/crt0.S
 create mode 100644 sysdeps/sigma/generic/entry.cpp
 create mode 100644 sysdeps/sigma/generic/generic.cpp
 create mode 100644 sysdeps/sigma/generic/log.cpp
 create mode 100644 sysdeps/sigma/generic/memory.cpp
 create mode 120000 sysdeps/sigma/include/abi-bits/abi.h
 create mode 120000 sysdeps/sigma/include/abi-bits/auxv.h
 create mode 120000 sysdeps/sigma/include/abi-bits/vm-flags.h
 create mode 100644 sysdeps/sigma/meson.build
 create mode 100644 sysdeps/sigma/rtld-generic/support.cpp

diff --git a/abis/sigma/abi.h b/abis/sigma/abi.h
new file mode 100644
index 0000000..55fbd68
--- /dev/null
+++ b/abis/sigma/abi.h
@@ -0,0 +1,23 @@
+
+// reserve 3 bits for the access mode
+#define __MLIBC_O_ACCMODE 0x0007
+#define __MLIBC_O_EXEC 1
+#define __MLIBC_O_RDONLY 2
+#define __MLIBC_O_RDWR 3
+#define __MLIBC_O_SEARCH 4
+#define __MLIBC_O_WRONLY 5
+// all remaining flags get their own bit
+#define __MLIBC_O_APPEND 0x0008
+#define __MLIBC_O_CREAT 0x0010
+#define __MLIBC_O_DIRECTORY 0x0020
+#define __MLIBC_O_EXCL 0x0040
+#define __MLIBC_O_NOCTTY 0x0080
+#define __MLIBC_O_NOFOLLOW 0x0100
+#define __MLIBC_O_TRUNC 0x0200
+#define __MLIBC_O_NONBLOCK 0x0400
+#define __MLIBC_O_DSYNC 0x0800
+#define __MLIBC_O_RSYNC 0x1000
+#define __MLIBC_O_SYNC 0x2000
+#define __MLIBC_O_CLOEXEC 0x4000
+
+
diff --git a/abis/sigma/auxv.h b/abis/sigma/auxv.h
new file mode 100644
index 0000000..0785c53
--- /dev/null
+++ b/abis/sigma/auxv.h
@@ -0,0 +1,9 @@
+#ifndef _ABIBITS_AUXV_H
+#define _ABIBITS_AUXV_H
+
+#define AT_PHDR 3
+#define AT_PHENT 4
+#define AT_PHNUM 5
+#define AT_ENTRY 9
+
+#endif
\ No newline at end of file
diff --git a/meson.build b/meson.build
index af40915..198ae03 100644
--- a/meson.build
+++ b/meson.build
@@ -74,6 +74,11 @@ elif host_machine.system() == 'qword'
 	rtdl_include_dirs += include_directories('sysdeps/qword/include')
 	libc_include_dirs += include_directories('sysdeps/qword/include')
 	subdir('sysdeps/qword')
+elif host_machine.system() == 'sigma'
+	disable_linux_option = true
+	rtdl_include_dirs += include_directories('sysdeps/sigma/include')
+	libc_include_dirs += include_directories('sysdeps/sigma/include')
+	subdir('sysdeps/sigma')
 else
 	error('No sysdeps defined for OS: ' + host_machine.system())
 endif
diff --git a/sysdeps/sigma/crt-src/crt0.S b/sysdeps/sigma/crt-src/crt0.S
new file mode 100644
index 0000000..e331397
--- /dev/null
+++ b/sysdeps/sigma/crt-src/crt0.S
@@ -0,0 +1,5 @@
+.section .text
+.global _start
+_start:
+    mov $main, %rdi
+    call __mlibc_entry
\ No newline at end of file
diff --git a/sysdeps/sigma/generic/entry.cpp b/sysdeps/sigma/generic/entry.cpp
new file mode 100644
index 0000000..917335c
--- /dev/null
+++ b/sysdeps/sigma/generic/entry.cpp
@@ -0,0 +1,28 @@
+#include <stdint.h>
+#include <stdlib.h>
+#include <bits/ensure.h>
+#include <mlibc/elf/startup.h>
+
+void __mlibc_initLocale();
+
+extern "C" uintptr_t* __dlapi_entrystack();
+
+extern char** environ;
+static mlibc::exec_stack_data __mlibc_stack_data;
+
+struct LibraryGuard {
+    LibraryGuard();
+};
+
+static LibraryGuard guard;
+
+LibraryGuard::LibraryGuard(){
+    __mlibc_initLocale();
+
+    mlibc::parse_exec_stack(__dlapi_entrystack(), &__mlibc_stack_data);
+    mlibc::set_startup_data(__mlibc_stack_data.argc, __mlibc_stack_data.argv, __mlibc_stack_data.envp);
+}
+
+extern "C" void __mlibc_entry(int (*main_fn)(int argc, char *argv[], char *env[])){
+    exit(main_fn(__mlibc_stack_data.argc, __mlibc_stack_data.argv, environ));
+}
\ No newline at end of file
diff --git a/sysdeps/sigma/generic/generic.cpp b/sysdeps/sigma/generic/generic.cpp
new file mode 100644
index 0000000..e2fe5a5
--- /dev/null
+++ b/sysdeps/sigma/generic/generic.cpp
@@ -0,0 +1,97 @@
+#include <mlibc/sysdeps.hpp>
+#include <bits/ensure.h>
+#include <libsigma/log.h>
+
+
+#define STUB_ONLY { __ensure(!"STUB_ONLY function was called"); __builtin_unreachable(); }
+
+namespace mlibc {
+    // Unknown Functions
+    int sys_tcb_set(void *pointer){
+	    libsigma_setfsbase(static_cast<uint64_t>(pointer));
+        return 0;
+    }
+    
+    int sys_sigaction(int signum, const struct sigaction *act, struct sigaction *oldact) STUB_ONLY
+    
+    // Memory Related Functions
+    int sys_vm_map(void *hint, size_t size, int prot, int flags, int fd, off_t offset, void **window) STUB_ONLY
+    #ifndef MLIBC_BUILDING_RTDL
+    int sys_vm_remap(void *pointer, size_t size, size_t new_size, void **window) STUB_ONLY
+    #endif
+    int sys_vm_unmap(void *pointer, size_t size) STUB_ONLY
+
+    // Misc functions
+    #ifndef MLIBC_BUILDING_RTDL
+    int sys_clock_get(int clock, time_t *secs, long *nanos) STUB_ONLY
+    int sys_futex_wait(int *pointer, int expected) STUB_ONLY
+    int sys_futex_wake(int *pointer) STUB_ONLY
+    #endif
+
+    // Task functions
+    #ifndef MLIBC_BUILDING_RTDL
+    void sys_exit(int status) STUB_ONLY
+    int sys_sleep(time_t *secs, long *nanos) STUB_ONLY
+    int sys_fork(pid_t *child) STUB_ONLY
+    int sys_execve(const char *path, char *const argv[], char *const envp[]) STUB_ONLY
+    int sys_kill(pid_t pid, int signal) STUB_ONLY
+    int sys_waitpid(pid_t pid, int *status, int flags, pid_t *ret_pid) STUB_ONLY
+    int sys_getrusage(int who, struct rusage *usage) STUB_ONLY
+    int sys_sigprocmask(int how, const sigset_t *__restrict set, sigset_t *__restrict retrieve) STUB_ONLY
+    void sys_yield() STUB_ONLY
+    gid_t sys_getgid() STUB_ONLY
+    gid_t sys_getegid() STUB_ONLY
+    uid_t sys_getuid() STUB_ONLY
+    uid_t sys_geteuid() STUB_ONLY
+    pid_t sys_getpid() STUB_ONLY
+    pid_t sys_getppid() STUB_ONLY
+    #endif
+
+    // File functions
+    int sys_open(const char *path, int flags, int *fd) STUB_ONLY
+    int sys_close(int fd) STUB_ONLY
+    int sys_seek(int fd, off_t offset, int whence, off_t *new_offset) STUB_ONLY
+    int sys_read(int fd, void *buf, size_t count, ssize_t *bytes_read) STUB_ONLY
+
+    #ifndef MLIBC_BUILDING_RTDL
+    int sys_write(int fd, const void *buf, size_t count, ssize_t *bytes_written) STUB_ONLY
+    int sys_ioctl(int fd, unsigned long request, void *arg, int *result) STUB_ONLY
+    int sys_stat(fsfd_target fsfdt, int fd, const char *path, int flags, struct stat *statbuf) STUB_ONLY
+    int sys_rename(const char *path, const char *new_path) STUB_ONLY
+    int sys_open_dir(const char *path, int *handle) STUB_ONLY
+    int sys_read_entries(int handle, void *buffer, size_t max_size, size_t *bytes_read) STUB_ONLY
+    int sys_access(const char *path, int mode) STUB_ONLY
+    int sys_dup(int fd, int flags, int *newfd) STUB_ONLY
+    int sys_dup2(int fd, int flags, int newfd) STUB_ONLY
+    int sys_isatty(int fd) STUB_ONLY
+    int sys_ttyname(int fd, char *buf, size_t size) STUB_ONLY
+    int sys_chroot(const char *path) STUB_ONLY
+    int sys_mkdir(const char *path) STUB_ONLY
+    int sys_tcgetattr(int fd, struct termios *attr) STUB_ONLY
+    int sys_tcsetattr(int fd, int optional_action, const struct termios *attr) STUB_ONLY
+    int sys_tcflow(int fd, int action) STUB_ONLY
+    int sys_pipe(int *fds, int flags) STUB_ONLY
+    int sys_readlink(const char *path, void *buffer, size_t max_size, ssize_t *length) STUB_ONLY
+    int sys_ftruncate(int fd, size_t size) STUB_ONLY
+    int sys_fallocate(int fd, off_t offset, size_t size) STUB_ONLY
+    int sys_unlink(const char *path) STUB_ONLY
+    int sys_symlink(const char *target_path, const char *link_path) STUB_ONLY
+    int sys_fcntl(int fd, int request, va_list args, int *result) STUB_ONLY
+    #endif
+
+    // Network related functions
+    #ifndef MLIBC_BUILDING_RTDL
+    int sys_socket(int family, int type, int protocol, int *fd) STUB_ONLY
+    int sys_socketpair(int domain, int type_and_flags, int proto, int *fds) STUB_ONLY
+    int sys_accept(int fd, int *newfd) STUB_ONLY
+    int sys_bind(int fd, const struct sockaddr *addr_ptr, socklen_t addr_length) STUB_ONLY
+    int sys_connect(int fd, const struct sockaddr *addr_ptr, socklen_t addr_length) STUB_ONLY
+    int sys_msg_send(int fd, const struct msghdr *hdr, int flags, ssize_t *length) STUB_ONLY
+    int sys_msg_recv(int fd, struct msghdr *hdr, int flags, ssize_t *length) STUB_ONLY
+    int sys_sockname(int fd, struct sockaddr *addr_ptr, socklen_t max_addr_length, socklen_t *actual_length) STUB_ONLY
+    int sys_getsockopt(int fd, int layer, int number, void *__restrict buffer, socklen_t *__restrict size) STUB_ONLY
+    int sys_setsockopt(int fd, int layer, int number, const void *buffer, socklen_t size) STUB_ONLY
+    #endif
+
+
+}
\ No newline at end of file
diff --git a/sysdeps/sigma/generic/log.cpp b/sysdeps/sigma/generic/log.cpp
new file mode 100644
index 0000000..eaad35e
--- /dev/null
+++ b/sysdeps/sigma/generic/log.cpp
@@ -0,0 +1,21 @@
+#include <string.h>
+#include <assert.h>
+
+#include <bits/ensure.h>
+#include <mlibc/debug.hpp>
+#include <mlibc/sysdeps.hpp>
+
+#define STRCAT(a, b) a##b
+#define UNIMPLEMENTED(msg) { __ensure(!STRCAT("Unimplemented function was called: ", msg)); __builtin_unreachable(); }
+
+namespace mlibc
+{
+    void sys_libc_log(const char *message) {
+        libsigma_log(message);
+    }
+
+    void sys_libc_panic(){
+        mlibc::infoLogger() << "\e[31mmlibc: panic!" << frg::endlog;
+        UNIMPLEMENTED("Exit isnt implemented yet");
+    }
+} // namespace mlibc
diff --git a/sysdeps/sigma/generic/memory.cpp b/sysdeps/sigma/generic/memory.cpp
new file mode 100644
index 0000000..6accb78
--- /dev/null
+++ b/sysdeps/sigma/generic/memory.cpp
@@ -0,0 +1,24 @@
+#include <string.h>
+
+#include <bits/ensure.h>
+#include <mlibc/sysdeps.hpp>
+#include <mlibc/debug.hpp>
+#include <libsigma/memory.h>
+
+#define STUB_ONLY { __ensure(!"STUB_ONLY function was called"); __builtin_unreachable(); }
+
+namespace mlibc
+{
+    int sys_anon_allocate(size_t size, void **pointer){
+        __ensure((size & 0xFFF) == 0);
+        uint64_t ret = libsigma_valloc(LIBSIGMA_VALLOC_TYPE_SBRK_LIKE, 0, size / 0x1000);
+        if(ret == 1) return 1;
+        *pointer = ret;
+
+        return 0;
+    }
+    int sys_anon_free(void *pointer, size_t size){
+        mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!" << frg::endlog;
+        return 0;
+    }
+} // namespace mlibc
diff --git a/sysdeps/sigma/include/abi-bits/abi.h b/sysdeps/sigma/include/abi-bits/abi.h
new file mode 120000
index 0000000..5cbf52e
--- /dev/null
+++ b/sysdeps/sigma/include/abi-bits/abi.h
@@ -0,0 +1 @@
+../../../../abis/sigma/abi.h
\ No newline at end of file
diff --git a/sysdeps/sigma/include/abi-bits/auxv.h b/sysdeps/sigma/include/abi-bits/auxv.h
new file mode 120000
index 0000000..9eae830
--- /dev/null
+++ b/sysdeps/sigma/include/abi-bits/auxv.h
@@ -0,0 +1 @@
+../../../../abis/sigma/auxv.h
\ No newline at end of file
diff --git a/sysdeps/sigma/include/abi-bits/vm-flags.h b/sysdeps/sigma/include/abi-bits/vm-flags.h
new file mode 120000
index 0000000..f1a985e
--- /dev/null
+++ b/sysdeps/sigma/include/abi-bits/vm-flags.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/vm-flags.h
\ No newline at end of file
diff --git a/sysdeps/sigma/meson.build b/sysdeps/sigma/meson.build
new file mode 100644
index 0000000..9a07dcf
--- /dev/null
+++ b/sysdeps/sigma/meson.build
@@ -0,0 +1,40 @@
+# sigma_incl = include_directories('../../subprojects/managarm/frigg/include',
+#		'../../subprojects/managarm/hel/include')
+
+#rtdl_include_dirs += managarm_incl
+rtdl_sources += files(
+	'generic/log.cpp',
+	'generic/memory.cpp',
+	'rtdl-generic/support.cpp',
+)
+
+#libc_include_dirs += include_directories('../../../ports/libdrm/include')
+#libc_include_dirs += managarm_incl
+
+libc_sources += files(
+	'generic/log.cpp',
+	'generic/entry.cpp',
+	'generic/memory.cpp',
+	'generic/generic.cpp',
+)
+
+if not no_headers
+	install_headers(
+		'include/abi-bits/abi.h',
+		'include/abi-bits/auxv.h',
+		'include/abi-bits/vm-flags.h',
+		subdir: 'abi-bits'
+	)
+endif
+
+if not headers_only
+	custom_target('crt0',
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: 'crt-src/crt0.S',
+		output: 'crt0.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+endif
+
diff --git a/sysdeps/sigma/rtld-generic/support.cpp b/sysdeps/sigma/rtld-generic/support.cpp
new file mode 100644
index 0000000..34e7dfa
--- /dev/null
+++ b/sysdeps/sigma/rtld-generic/support.cpp
@@ -0,0 +1,94 @@
+#include <stddef.h>
+#include <stdint.h>
+#include <string.h>
+
+#include <frg/vector.hpp>
+#include <frg/string.hpp>
+
+#include <mlibc/allocator.hpp>
+#include <mlibc/sysdeps.hpp>
+
+#include <libsigma/thread.h>
+#include <libsigma/file.h>
+
+namespace {
+    class id_allocator{
+        public:
+        id_allocator(): id(0) {}
+
+        uint64_t get_id(){
+            return id++;
+        } 
+
+        private:
+        uint64_t id;
+    };
+
+    auto file_descriptor_allocator = id_allocator();
+
+    struct file_descriptor {
+        file_descriptor(): fd(0), offset(0), name(frg::string()) {}
+        file_descriptor(const char* name): fd(file_descriptor_allocator.get_id()), offset(0), name(frg::string<MemoryAllocator>(name)) {}
+        uint64_t fd, offset;
+        frg::string<MemoryAllocator> name;
+    };
+
+static frg::vector<file_descriptor, MemoryAllocator>& get_file_descriptor_list(){
+        static frg::eternal<frg::vector<file_descriptor, MemoryAllocator>> file_descriptor_list(getAllocator());
+        return file_descriptor_list.get();
+    }
+    
+}
+
+
+namespace mlibc {
+
+int sys_tcb_set(void *pointer) {
+	libsigma_setfsbase(static_cast<uint64_t>(pointer));
+	return 0;
+}
+
+int sys_open(const char *path, int flags, int *fd){
+    auto& file = file_descriptor_list.push_back(file_descriptor(path));
+    (void)(flags);
+    *fd = file.fd;
+    return 0;
+}
+
+int sys_seek(int fd, off_t offset, int whence, off_t *new_offset){
+    __ensure(whence == SEEK_SET);
+
+    for(auto& file : file_descriptor_list){
+        if(file.fd == fd){
+            file.offset = offset;
+            *new_offset = offset;
+            return 0;
+        }
+    }
+
+    return 1;
+}
+int sys_read(int fd, void *data, size_t length, ssize_t *bytes_read){
+    libsigma_read_initrd_file()
+
+    or(auto& file : file_descriptor_list){
+        if(file.fd == fd){
+            libsigma_read_initrd_file(file.name.c_str(), data, length, bytes_read);
+        }
+    }
+
+    return 1;
+}
+int sys_close(int fd){
+    return 0;
+}
+
+int sys_vm_map(void *hint, size_t size, int prot, int flags, int fd, off_t offset, void **window);
+    if(!(flags & MAP_ANONYMOUS)) __ensure(!"Anything else than MAP_ANONYMOUS is unimplemented");
+
+    int ret = libsigma_vm_map(size, hint, prot, flags);
+    *window = hint;
+    return ret;
+} // namespace mlibc
+
+}
-- 
2.20.1

